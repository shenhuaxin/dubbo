## Rpc: Dubbo如何进行Rpc调用。


### Invoker、Exporter
#### 接口
消费者和提供者都会使用到这个接口
1. 消费者将多个ExchangeClient封装为一个Invoker。 在调用Invoker.invoke时会向服务提供者发送请求。     
2. 在服务提供者端，会使用ProxyFactory将被代理对象封装为一个Invoker。在接收消费者的请求时，进行Invoker.invoke()调用，获得结果，并返回。      
```java
public interface Invoker<T> extends Node {
    /** 获取这个Invoker所代表的接口 **/
    Class<T> getInterface();
    /** 使用Invoker进行一个调用 **/
    Result invoke(Invocation invocation) throws RpcException;
}
```
只有提供者使用这个接口     
1. Protocol维护了一个ServiceKey，Exporter的Map。并在暴露服务时，将Invoker封装为Exporter, 并放入exporterMap中, 在接收请求时，根据url获得Exporter, 在得到Invoker.
```java
public interface Exporter<T> {
    /** 获取
    Invoker<T> getInvoker();

    void unexport();

}
```
#### 流程
##### 服务提供方
1. 有一个真正需要被调用的对象ref（Dubbo的@Service标注的类的对象），使用ProxyFactory.getInvoker，将ref封装为一个Invoker.
2. 将Invoker封装为Exporter。 在Protocol中维护了Map<String, Exporter<?>>。  key为URL。将Exporter放入Map中。
3. 在接收消费者的请求时，根据消费者的URL获取Exporter。 从Exporter中获取Invoker。调用invoke()函数。执行生成的动态代理对象。
4. 返回最后结果。

##### 服务消费方
1. 根据需要消费的URL, 使用Protocol.refer创建ExchangeClient。并将ExchangeClient封装为一个Invoker.
2. 使用ProxyFactory.getProxy()将Invoker封装为一个@Reference标注接口的实现类。
3. 之后用户便可以使用这个代理类进行远程调用。

### Protocol

![Protocol类图](../z-image/rpc/Protocol类图.png)



