## Netty


### Channel

### ChannelHandler



#### 对InBound和OutBound的理解

下面的问题是别人在stackoverflow上的提问，由netty的开发者进行回答。 我们从中可以很好的理解 InboundChannelHandler 和 OutboundHandler
##### 提问
I have a question in Netty4, An I/O event is handled by either a ChannelInboundHandler or a ChannelOutboundHandler

1. The first question is why read and write method both in ChannelOutboundHandler?
2. why trigger read() method in the fireChannelReadComplete()? What is the design philosophy?

我对Netty4有个疑问， 一个IO事件会被ChannelInboundHandler或ChannelOutboundHandler处理。
1. 第一个问题是， 为什么ChannelOutboundHandler中既有write函数， 又有read函数。
2. 为什么在fireChannelReadComplete中会触发read函数， 设计哲学是什么？ 
```java
@Override
public ChannelPipeline fireChannelReadComplete() {
    head.fireChannelReadComplete();
    if (channel.config().isAutoRead()) {
        read();
    }
    return this;
}
```
注： 第二个问题提到的代码在现在的Netty中已不存在。（因为是5、6年前的问题）。 

##### 回答
Inbound handlers are supposed to handle inbound events. Events are triggered by external stimuli such as data received from a socket.   
Inbound 处理器会处理 inbound事件， 外部的刺激会触发这些事件， 例如socket接收到了数据。     
Outbound handlers are supposed to intercept the operations issued by your application.      
Outbound 处理器 会拦截由我们应用的操作。

Re: Q1) read() is an operation you can issue to tell Netty to continue reading the inbound data from the socket, and that's why it's in an outbound handler.    
问题1： read() 是一个操作， 你告诉Netty应该继续从socket中读取数据。 （read是由应用主动触发的， 这里的read，应该是channel.read）， 这也就是为什么read函数在outbound handler中。     

Re: Q2) You don't usually issue a read() operation because Netty does that for you automatically if autoRead property is set to true. Typical flow when autoRead is on:     
问题2： 通常不会调用read, 因为Netty会自动调用read, 如果属性autoRead为true的话。  autoRead有效时的典型流程如下。    
1. Netty triggers an inbound event channelActive when socket is connected, and then issues a read() request to itself (see DefaultChannelPipeline.fireChannelActive())
   当一个socket连接完成之后， Netty会触发一个 inbound event 事件channelActive ， 然后向自身发起一个read请求。      
2. Netty reads something from the socket in response to the read() request.     
   Netty 从socket中读取一些数据， 以响应read请求。     
3. If something was read, Netty triggers channelRead().
   如果一些数据被读取了， Netty会触发channelRead.     
4. If there's nothing left to read, Netty triggers channelReadComplete()        
   如果这里没有数据可读了， Netty会触发 channelReadComplete        
5. Netty issues another read() request to continue reading from the socket.         
   Netty 发起另一个 read 请求， 以继续从Socket中读取数据。

If autoRead is off, you have to issue a read() request manually. It's sometimes useful to turn autoRead off. For example, you might want to implement a backpressure mechanism by keeping the received data in the kernel space.    
如果关闭了autoRead， 你必须手动发起一次read请求。 有时候关闭autoRead很有用。 比如, 你可能想通过将接收到的数据保存在内核空间中来实现背压机制。

背压机制： 客户端发送的数据远超过服务端能处理的速度。 背压机制，会使服务端丢弃客户端的请求。如果是TCP, 那么就会减小窗口，导致客户端降低自己的发送速度。





####InBound


####OutBound


#### 顺序