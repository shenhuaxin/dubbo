## Remoting


### Channel


### ChannelHandler


### Client


### Server


### Transport


### Exchanger

```
Exchangers --> Exchanger --> HeaderExchanger.bind     ->  HeaderExchangeServer  ->  Transporters.bind     ->  Transporter  -->  NettyTransporter.bind     -> NettyServer
Exchangers --> Exchanger --> HeaderExchanger.connect  ->  HeaderExchangeClient  ->  Transporters.connect  ->  Transporter  -->  NettyTransporter.connect  -> NettyClient
```

就这样一层层的获得了NettyServer和NettyClient。  
并且我们看到在HeaderExchanger中对传递进来的 ChannelHandler 进行了两次包装。   
最外层为DecodeHandler， 然后是HeaderExchangeHandler, 最后是传递进来的handler
```java
public class HeaderExchanger implements Exchanger {

    public static final String NAME = "header";

    @Override
    public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
        // ExChange 委托 Transport 进行通信
        return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);
    }
    @Override
    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
        // ExChange 委托 Transport 进行通信
        return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
    }
}
```

在NettyClient 和 NettyServer 的构造函数中 又会将传递进来的handler进行包装。  
这里拿NettyClient举例。
```java
public NettyClient(final URL url, final ChannelHandler handler) throws RemotingException {
    super(url, wrapChannelHandler(url, handler));
}
protected static ChannelHandler wrapChannelHandler(URL url, ChannelHandler handler) {
    return ChannelHandlers.wrap(handler, url);
}
protected ChannelHandler wrapInternal(ChannelHandler handler, URL url) {
    // MultiMessageHandler -> HeartbeatHandler -> handler
    return new MultiMessageHandler(new HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.class)
            .getAdaptiveExtension().dispatch(handler, url)));
}
```
这里又使用 MultiMessageHandler 最外层包装， 然后是HeartbeatHandler包装， 
再是 Dispatch对应的Handler，如AllDispatcher对应的是AllChannelHandler， 最后是传递进来的Handler。


结合上面两个地方对Handler的包装， 最后的包装结果为： 

MultiMessageHandler  ->  HeartbeatHandler  ->  Dispatch对应的Handler  ->  DecodeHandler  ->  HeaderExchangeHandler  ->  传递进来的handler